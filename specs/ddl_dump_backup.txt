-- 1) Extensions (create where allowed)
-- Some extensions require superuser or provider approval in hosted environments.
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS postgis_topology;
CREATE EXTENSION IF NOT EXISTS postgis_raster;
CREATE EXTENSION IF NOT EXISTS pgroonga;
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS uuid-ossp;
CREATE EXTENSION IF NOT EXISTS pgsodium;
CREATE EXTENSION IF NOT EXISTS pg_repack;
CREATE EXTENSION IF NOT EXISTS pg_partman;
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS pgjwt;
CREATE EXTENSION IF NOT EXISTS supabase_vault;
-- (and other extensions from the list as needed)
-- NOTE: If any CREATE EXTENSION fails, you can comment it out. Hosted Supabase may restrict some extensions.

-- 2) Public schema types (enums / custom types)
-- profile_type
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'profile_type') THEN
    CREATE TYPE profile_type AS ENUM ('owner','crew');
  END IF;
END$$;

-- boat_type
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'boat_type') THEN
    CREATE TYPE boat_type AS ENUM ('sailboat','motorboat');
  END IF;
END$$;

-- risk_level enum used in journeys (single-item array type _risk_level used automatically)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'risk_level') THEN
    CREATE TYPE risk_level AS ENUM ('Coastal sailing','Offshore sailing','Extreme sailing');
  END IF;
END$$;

-- 3) Tables: public.profiles
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid PRIMARY KEY,
  role profile_type NOT NULL DEFAULT 'crew'::profile_type,
  full_name text,
  experience text,
  certifications text,
  phone text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  username text UNIQUE,
  sailing_experience text
);

-- Foreign key: profiles.id -> auth.users.id
-- This references auth.users which is typically in the 'auth' schema created by Supabase.
ALTER TABLE public.profiles
  ADD CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users (id) ON DELETE CASCADE;

-- 4) Tables: public.boats
CREATE TABLE IF NOT EXISTS public.boats (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id uuid,
  name text,
  type boat_type NOT NULL DEFAULT 'sailboat'::boat_type,
  make text,
  model text,
  capacity integer,
  home_port text,
  loa_m numeric,
  beam_m numeric,
  displcmt_m numeric,
  link_to_specs text,
  images text[] DEFAULT '{}'::text[],
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Foreign key: boats.owner_id -> auth.users.id
ALTER TABLE public.boats
  ADD CONSTRAINT boats_owner_id_fkey FOREIGN KEY (owner_id) REFERENCES auth.users (id) ON DELETE SET NULL;

-- 5) Tables: public.journeys
CREATE TABLE IF NOT EXISTS public.journeys (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  boat_id uuid,
  name text,
  start_date date,
  end_date date,
  description text,
  is_public boolean NOT NULL DEFAULT true,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  risk_level risk_level[]  -- array of enum risk_level
);

-- Foreign key: journeys.boat_id -> public.boats.id
ALTER TABLE public.journeys
  ADD CONSTRAINT journeys_boat_id_fkey FOREIGN KEY (boat_id) REFERENCES public.boats (id) ON DELETE CASCADE;

-- 6) Tables: public.legs
CREATE TABLE IF NOT EXISTS public.legs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  journey_id uuid,
  name text,
  start_port text,
  end_port text,
  start_geocode jsonb,
  end_geocode jsonb,
  start_date timestamptz,
  end_date timestamptz,
  crew_needed integer,
  skills text[] DEFAULT '{}'::text[],
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Foreign key: legs.journey_id -> public.journeys.id
ALTER TABLE public.legs
  ADD CONSTRAINT legs_journey_id_fkey FOREIGN KEY (journey_id) REFERENCES public.journeys (id) ON DELETE CASCADE;

-- 7) Indexes recommended (FKs and RLS columns)
CREATE INDEX IF NOT EXISTS idx_boats_owner_id ON public.boats(owner_id);
CREATE INDEX IF NOT EXISTS idx_journeys_boat_id ON public.journeys(boat_id);
CREATE INDEX IF NOT EXISTS idx_legs_journey_id ON public.legs(journey_id);
CREATE INDEX IF NOT EXISTS idx_profiles_username ON public.profiles(username);

-- If you plan to query arrays or jsonb, consider additional indexes:
CREATE INDEX IF NOT EXISTS idx_journeys_risk_level_gin ON public.journeys USING GIN (risk_level);
CREATE INDEX IF NOT EXISTS idx_legs_start_geocode_gin ON public.legs USING GIN (start_geocode);
CREATE INDEX IF NOT EXISTS idx_legs_end_geocode_gin ON public.legs USING GIN (end_geocode);

-- 8) Enable Row Level Security where reported enabled
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.boats ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.journeys ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.legs ENABLE ROW LEVEL SECURITY;

-- 9) Optional: Example safe RLS policies (do not enable them blindly)
-- These examples restrict access to rows owned by auth.uid() where appropriate.
-- Adjust to your application logic before enabling.

-- Example: profiles — allow user to SELECT/INSERT/UPDATE/DELETE only their own profile
CREATE POLICY IF NOT EXISTS profiles_user_self_select ON public.profiles
  FOR SELECT TO authenticated
  USING ((SELECT auth.uid()) = id);

CREATE POLICY IF NOT EXISTS profiles_user_self_insert ON public.profiles
  FOR INSERT TO authenticated
  WITH CHECK ((SELECT auth.uid()) = id);

CREATE POLICY IF NOT EXISTS profiles_user_self_update ON public.profiles
  FOR UPDATE TO authenticated
  USING ((SELECT auth.uid()) = id)
  WITH CHECK ((SELECT auth.uid()) = id);

CREATE POLICY IF NOT EXISTS profiles_user_self_delete ON public.profiles
  FOR DELETE TO authenticated
  USING ((SELECT auth.uid()) = id);

-- Example: boats — allow owner to manage boats they own
CREATE POLICY IF NOT EXISTS boats_owner_select ON public.boats
  FOR SELECT TO authenticated
  USING (owner_id = (SELECT auth.uid())::uuid);

CREATE POLICY IF NOT EXISTS boats_owner_insert ON public.boats
  FOR INSERT TO authenticated
  WITH CHECK (owner_id = (SELECT auth.uid())::uuid);

CREATE POLICY IF NOT EXISTS boats_owner_update ON public.boats
  FOR UPDATE TO authenticated
  USING (owner_id = (SELECT auth.uid())::uuid)
  WITH CHECK (owner_id = (SELECT auth.uid())::uuid);

CREATE POLICY IF NOT EXISTS boats_owner_delete ON public.boats
  FOR DELETE TO authenticated
  USING (owner_id = (SELECT auth.uid())::uuid);

-- Example: journeys — allow access for journeys that are public OR owned via boat owner relation
CREATE POLICY IF NOT_EXISTS journeys_public_or_boat_owner_select ON public.journeys
  FOR SELECT TO authenticated
  USING (
    is_public = true
    OR EXISTS (
      SELECT 1 FROM public.boats b WHERE b.id = public.journeys.boat_id AND b.owner_id = (SELECT auth.uid())::uuid
    )
  );

-- Note: you may prefer to create a helper function to map auth.uid() to your user profile/tenant.

-- 10) Additional: recreate sequences or defaults if needed
-- The default gen_random_uuid() depends on pgcrypto; ensure pgcrypto installed.

-- 11) Grant ownership / privileges as appropriate (example)
-- Owner statements depend on your desired DB roles. By default, objects will be created under the current role.

-- End of DDL